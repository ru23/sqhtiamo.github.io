<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Web Components v1 - 下一代的Web Component]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F10%2Fchrome%2Fweb-component-v1%2F</url>
      <content type="text"><![CDATA[原文: https://developers.google.com/web/updates/2017/01/webcomponents-org作者：Taylor Savage (Taylor is a PM on the Chrome Team, focusing on Web Components and Polymer.) Web ComponentsEver wanted to build your own self-contained JavaScript component, that you can easily use across multiple projects or share with other developers regardless of what JavaScript framework they use? Web Components may be for you. Web Components are a set of new web platform features that let you create your own HTML elements. Each new custom element can have a custom tag like , and have all the goodness of built-in elements - custom elements can have properties and methods, fire and respond to events, and even have an encapsulated style and DOM trees to bring along their own look and feel. By providing a platform-based, low-level component model, Web Components let you build and share re-usable elements for everything from specialized buttons to complex views like datepickers. Because Web Components are built with platform API’s which include powerful encapsulation primitives, you can even use these components within other JavaScript libraries or frameworks as if they were standard DOM elements. You may have heard of Web Components before - an early version of the Web Components spec - v0 - was shipped in Chrome 33. Today, thanks to broad collaboration between browser vendors, the next-generation of the Web Components spec - v1 - is gaining wide support. Chrome supports the two major specs that make up Web Components - Shadow DOM and Custom Elements - as of Chrome 53 and Chrome 54 respectively. Safari shipped support for Shadow DOM v1 in Safari 10, and has completed implementation of Custom Elements v1 in WebKit. Firefox is currently developing Shadow DOM and Custom Elements v1, and both Shadow DOM and Custom Elements are on the roadmap for Edge. To define a new custom element using the v1 implementation, you simply create a new class that extends HTMLElement using ES6 syntax and register it with the browser:12class MyElement extends HTMLElement &#123;...&#125;window.customElements.define('my-element', MyElement); The new v1 specs are extremely powerful - we’ve put together tutorials on using Custom Elements v1 and Shadow DOM v1 to help you get started. webcomponents.orgThe Web Component community is also growing in leaps and bounds. We’re excited to see the launch of an updated webcomponents.org site - the focal point of the web components community - including an integrated catalog for developers to share their elements. The webcomponents.org site contains information about the Web Components specs, updates and content from the web components community, and displays documentation for open-source elements and collections of elements built by other developers. You can get started building your first element using a library like Google’s Polymer, or just use the low-level Web Component API’s directly. Then publish your element on webcomponents.org. Happy componentizing!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chrome 56 Beta]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Fchrome%2Fchrome56%2F</url>
      <content type="text"><![CDATA[原文:http://developers.googleblog.cn/2016/12/chrome-56-betanot-secure-css-position.html 1. HTTP 密码和信用卡页面的“Not Secure”警告 2. 网络蓝牙Web Bluetooth API 3. CSS position: sticky4. Referrer-Policyhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTMl5标签]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Fhtml5%2Ftag%2F</url>
      <content type="text"><![CDATA[原文:https://www.sitepoint.com/eight-html5-tags-you-might-not-know/?utm_source=frontendfocus&amp;utm_medium=email 1.1 标记和当前用户的相关性，与strong区分，用黄色底标记出来 1.2 应用于footer、aside远离正文；用于不重要的补充说明 1.3 q: 短的行内引用 blockquote: 大段引用 注意和cite进行区分 1.4 结合cite和datetime属性一起使用 s表示删除之后，还有新的更新代替 1.5 label 只能看，不能选 disabled: 里面的options都不可选 1.6 结合input作multi－select12345678910111213&lt;label for=&quot;favourite-sites&quot;&gt; Select your favorite website!&lt;/label&gt;&lt;input type=&quot;url&quot; name=&quot;favourite-sites&quot; id=&quot;favourite-sites&quot; list=&quot;site-list&quot;/&gt;&lt;datalist id=&quot;site-list&quot;&gt; &lt;option value=&quot;http://www.google.com.au&quot;&gt; &lt;option value=&quot;http://www.reddit.com&quot;&gt; &lt;option value=&quot;http://www.sitepoint.com&quot;&gt;&lt;/datalist&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html标准学习]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Fstandard%2Fhtml5%2F</url>
      <content type="text"><![CDATA[4. DOMbasehreftarget 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enum DocumentReadyState &#123; &quot;loading&quot;, &quot;interactive&quot;, &quot;complete&quot; &#125;;[OverrideBuiltins]partial /*sealed*/ interface Document &#123; // resource metadata management [PutForwards=href, Unforgeable] readonly attribute Location? location; attribute DOMString domain; readonly attribute DOMString referrer; attribute DOMString cookie; readonly attribute DOMString lastModified; readonly attribute DocumentReadyState readyState; // DOM tree accessors getter object (DOMString name); attribute DOMString title; attribute DOMString dir; attribute HTMLElement? body; readonly attribute HTMLHeadElement? head; readonly attribute HTMLCollection images; readonly attribute HTMLCollection embeds; readonly attribute HTMLCollection plugins; readonly attribute HTMLCollection links; readonly attribute HTMLCollection forms; readonly attribute HTMLCollection scripts; NodeList getElementsByName(DOMString elementName); // dynamic markup insertion Document open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;); WindowProxy open(DOMString url, DOMString name, DOMString features, optional boolean replace = false); void close(); void write(DOMString... text); void writeln(DOMString... text); // user interaction readonly attribute WindowProxy? defaultView; readonly attribute Element? activeElement; boolean hasFocus(); attribute DOMString designMode; boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;); boolean queryCommandEnabled(DOMString commandId); boolean queryCommandIndeterm(DOMString commandId); boolean queryCommandState(DOMString commandId); boolean queryCommandSupported(DOMString commandId); DOMString queryCommandValue(DOMString commandId); // special event handler IDL attributes that only apply to Document objects [LenientThis] attribute EventHandler onreadystatechange;&#125;;Document implements GlobalEventHandlers; 7. scripts11. Obsolete features11.1 Warnings obsolete permitted DOCTYPE border of ‘img’ when value=”0” [other situation is Non-conforming features] (use CSS instead) language=JavaScript and no type=”text/JavaScript” name on element and value is no empty String maxLength when input type=”number” size when input type=”number” 11.2 Non-conforming features Element Attribute 11.3 Requirements for implementations applet marquee (slides effect use CSS animation instead) frame Application cache Others 12. IANA considerations1IANA:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛视频直播学习笔记]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Flive%2Fqiniu%2F</url>
      <content type="text"><![CDATA[一、《视频直播技术详解》系列之一：开篇参考:《视频直播技术详解》系列之一：开篇 1. 主要流程原作者给的流程图： 1.1 采集 iOS 系统因为软硬件种类不多，硬件适配性较好，所以比较简单。 Android 则不同，市面上硬件机型非常多，难以做到一个库适配所有硬件。 PC 端的采集也跟各种摄像头驱动有关，推荐使用目前市面上最好用的 PC 端开源免费软件 OBS。 1.2 处理 视频处理如模糊效果、水印等也都是在这个环节做。 iOS 端比较知名的是 GPUImage 这个库，提供了丰富端预处理效果，还可以基于这个库自己写算法实现更丰富端效果。 Android 也有 GPUImage 这个库的移植，叫做 android-gpuimage。同时，Google 官方开源了一个伟大的库，覆盖了 Android 上面很多多媒体和图形图像相关的处理。(啥库？没说啊。。。) 1.3 编码 处理硬件兼容性问题。（硬件兼容性？不懂。。。） 在高 fps、低 bitrate 和音质画质之间找到平衡。 iOS 端硬件兼容性较好，可以直接采用硬编。 Android 的硬编的支持则难得多，需要支持各种硬件机型，推荐使用软编。 1.4 推流和传输 从主播端到服务端，从收流服务端到边缘节点，以及再从边缘节点到观众端。 推流端和分发端理论上需要支持的并发用户数应该都是亿级的， 不过毕竟产生内容的推流端在少数对推流稳定性和速度的要求比播放端高很多 现在的CDN不靠谱 你能够借助CDN快速实现大规模的流分发 但是稳定高速的推流上传可能还需要自己做很多工作 七牛打造了一个直播专属的实时流网络 1.5 转码 转码成不同格式支持不同协议如 RTMP、HLS 和 FLV，一路转多路流来适配各种不同的网络状况和不同分辨率的终端设备。 内容识别，如：鉴黄功能。 1.6 解码和渲染 iOS 端的播放兼容性较好，在延迟可接受的情况下使用 HLS 协议是最好的选择 + RTMP 和 HLS 的播放器 SDK。 Android 的硬件解码和编码一样也存在兼容性问题，目前比较好的开源播放器是基于 ffplay 的 ijkplayer + Android SDK。 1.7 直播场景化解决方案 社交直播下的聊天、点赞和弹幕的支持 二、《视频直播技术详解》系列之二：采集参考:《视频直播技术详解》系列之二：采集 1. 采集内容1.1 音频采集 模拟信号 －&gt; PCM编码的原始数据（模拟变数字，采样、量化、编码） －&gt; 压缩数据 常见的音频压缩格式有：MP3，AAC，OGG，WMA，Opus，FLAC，APE，m4a 和 AMR 等。 挑战: 延时敏感、卡顿敏感、噪声消除（Denoise）、回声消除（AEC）、静音检测（VAD）和各种混音算法等。(这些是什么？需要好好恶补一下。。。) 技术参数 采样率 位宽：量化（16bit/32bit） 声道数: 录制时的音源数量或回放时相应的扬声器数量 音频帧: 音频数据是流式的，本身没有明确的一帧帧的概念。一般约定为2.5ms~60ms size ＝ 采样率（kHz）X 位宽（bit）X 声道数 X 帧长（ms） 1.2 图像采集 摄像头等设备拍摄成 YUV 编码的原始数据 -&gt; 编码压缩成 H.264 等格式 常见的视频封装格式有：MP4、3GP、AVI、MKV、WMV、MPG、VOB、FLV、SWF、MOV、RMVB 和 WebM 挑战: 设备兼容性差、延时敏感、卡顿敏感以及各种对图像的处理操作如美颜和水印等。 技术参数 图像传输格式: 通用影像传输格式（Common Intermediate Format）是视讯会议（video conference）中常使用的影像传输格式。 图像格式: 通常采用 YUV 格式存储原始数据信息，其中包含用 8 位表示的黑白图像灰度值，以及可由 RGB 三种色彩组合成的彩色图像。 传输通道: 正常情况下只需1路通道，随着VR和AR技术的日渐成熟，为了拍摄一个完整的 360° 视频，可能需要通过不同角度拍摄，然后经过多通道传输后合成。 分辨率: 视频采集卡能支持的最大点阵反映了其分辨率的性能。 采样频率: 采样频率反映了采集卡处理图像的速度和能力。在进行高度图像采集时，需要注意采集卡的采样频率是否满足要求。 实际开发过程中可能很少能够关注采集环节中技术参数的控制，而是直接在 SDK 中将采集后的数据传递给下一个「处理」和「编码」环节。 2. 采集源 2.1 摄像头采集 手机上 ios/Android（&gt;4.0.3） 前后摄像头 专业摄像头：七牛云提供了兼容适合嵌入式系统的C语言采集模块的实现https://github.com/pili-engineering/ipcam_sdk（啥意思？驱动？or 接口？） 2.2 屏幕录制 iOS 9 以上的版本: 通过模拟一个 AirPlay 镜像连接到（当前 App）自身。 Android SDK: 实现了屏幕录制的功能 电脑桌面: 开源的桌面推流工具 OBS 来进行屏幕录制和推流：https://obsproject.com/ 2.3 视频文件 将一个视频或者音频文件以直播流的形式实时传输 2.4 开放式设计（接口） 只要采集源实现方遵循相应的接口，即可支持任意的采集源。 三、《视频直播技术详解》系列之三：处理参考:《视频直播技术详解》系列之三：处理 1. 开放式设计 音频处理中具体包含混音、降噪和声音特效 视频处理中包含美颜、水印、以及各种自定义滤镜 自定义处理 iOS SDK Android SDK 2. 美颜 主要原理: “磨皮”+”美白” 磨皮: 去躁。对图像中的噪点进行去除或者模糊化处理，常见的去噪算法有均值模糊、高斯模糊和中值滤波 + 人脸和皮肤检测技术。 美颜接口(ios SDK)： 按照默认参数开启或关闭美颜: 1(void)setBeautifyModeOn:(BOOL)beautifyModeOn; 设置美颜程度，范围为 0 ~ 1: 1(void)setBeautify:(CGFloat)beautify; 设置美白程度，范围为 0 ~ 1: 1(void)setWhiten:(CGFloat)whiten; 设置红润程度，范围为 0 ~ 1: 1(void)setRedden:(CGFloat)redden; 3. 视频内嵌水印 水印功能接口(ios SDK) 添加水印: 1(void)setWaterMarkWithImage:(UIImage *)wateMarkImage position:(CGPoint)position; 移除水印: 1(void)clearWaterMark; 4. 滤镜 iOS 端可以考虑使用GPUImage这个库。内置了多达120多种常见的滤镜效果。 Android 也有GPUImage这个库的移植 Google 官方也开源了一个伟大的库https://github.com/google/grafika 5. 连麦 技术难点: 低延迟互动 音画同步 视频实时合成: 需要在客户端或者服务端将画面和声音实时合成，然后以低成本高品质的方式传输观众端 思科或者 WebEx 的商用方案: 一不开源，二比较封闭，三成本比较高 WebRTC 通过 RTCPeerConnection API 管理，这个 API 包装了底层流管理和信令控制相关的细节 可以每个点之间形成自组织网络的方式通信;也可以以 1 人为中心形成星型通信网络;还可以让大家都通过一个集中式的服务端进行通信。 七牛直播云经过评估选择了以主播为中心形成星形通信网络，支持主播和多个观众之间的互动质量。 同时，为了保证合成后的音视频实时传输到其他观众端，这里采用经过改造的 UDP 协议传输： 通过 UDP 降低传输延迟。 在 UDP 之上进行传输控制，保证用户互动体验 QoS。 四、《视频直播技术详解》之四：编码和封装参考:《视频直播技术详解》之四：编码和封装 五、《视频直播技术详解》系列之五：推流和传输参考:《视频直播技术详解》系列之五：推流和传输 六、《视频直播技术详解》系列之六：延迟优化参考:《视频直播技术详解》系列之六：延迟优化 七、《视频直播技术详解》系列之七：现代播放器原理参考:《视频直播技术详解》系列之七：现代播放器原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tree-shaking介绍]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Fwebpack%2Ftree-shaking%2F</url>
      <content type="text"><![CDATA[1. 什么是tree-shaking?tree-shaking 由rollup.js提出的feature，使得js（ES2015）在打包的过程中，只需要引入需要用到的js部分，而不需要将整个js模块文件都打包。 2. webpack2如何做tree-shaking两步： - 去除所有没有被import引入的export； - 在minify的过程中，去除没有被用到的其它代码。 参考http://www.2ality.com/2015/12/webpack-tree-shaking.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Iterm2 Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fiterm2%2F</url>
      <content type="text"><![CDATA[基本操作12345678910111213control + a: 到行首control + e: 行末control + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快control + p: 上一条命令，相当于方向键上control + r: 搜索命令历史，这个大家都应该很熟悉了control + d: 删除当前字符control + h: 删除之前的字符control + w: 删除光标前的单词control + k: 删除到文本末尾control + t: 交换光标处文本control + u: 删除一行 + —/+/0: 调整字体大小⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到 参考http://hujiandong.com/2016/09/11/iterm2/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fsublime%2F</url>
      <content type="text"><![CDATA[1. 设置lnln /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl sublime 2. short-cuts2.1 Key Bindings - Default/User2.2 常用123456789option -&gt;/&lt;-option shift -&gt;/&lt;-command -&gt;/&lt;-command ［上］/［下］command entercommand Lcommand K+Bctrl shift M 选中代码块ctrl command G 选中相同的代码 3. 命令行sublime.log_commands(True) 4. package git 12345[ &#123; &quot;keys&quot;: [&quot;super+alt+g+a&quot;], &quot;command&quot;: &quot;git_raw&quot;, &quot;args&quot;: &#123;&quot;command&quot;: &quot;git add -A&quot; &#125;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+g+c&quot;], &quot;command&quot;: &quot;git_commit&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+g+p&quot;], &quot;command&quot;: &quot;git_raw&quot;, &quot;args&quot;: &#123;&quot;command&quot;: &quot;git push&quot; &#125;&#125;,] SyncedSideBar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tmux Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Ftmux%2F</url>
      <content type="text"><![CDATA[1. tmux a2. ctrl+B [ctrl+Bfix]3. 浏览历史ctrl+B [ 4. 新建ctrl+B C 5. 切换ctrl+B 1 6. 分屏ctrl+B %ctrl+B “ 7. 分屏到单屏ctrl+B z 8. 控制分屏大小ctrl+B alt＋&lt;- 9. 多个tmuxtmux new -s yuhangctrl+B s 10. tmux 配置 新建文件 ~/.tmux.conf 配置 1234567891011# 支持鼠标set -g mouse on# 已经废弃set -g mode-mouse onset -g mouse-resize-pane onset -g mouse-select-pane onset -g mouse-select-window on# 更改prefix键set -g prefix C-a 保存prefixsource-fille ~/.tmux.conf]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Yarn 基本介绍]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fyarn%2F</url>
      <content type="text"><![CDATA[1. 什么是yarn？2. yarn有什么好处？3. 性能如何？yarn的官网给出如下数据（yarn VS npm）：从warm cache, node_modules, Lockfile/Shrinkwarp 3个参数，8个维度进行比较。比较结果如下： 大部分情况下，yarn远胜于npm。 3. 安装3.1 下载安装mac操作系统： 用homebrew安装 12brew updatebrew install yarn 用curl安装 1curl -o- -L https://yarnpkg.com/install.sh | bash 用tarball安装 123cd /optwget https://yarnpkg.com/latest.tar.gztar zvxf yarn-*.tar.gz 3.2 环境变量修改：1export PATH=&quot;$HOME/.yarn/bin:$PATH 4. 使用 参考官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 代码管理]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F08%2Fjavascript%2FJS%20%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[1. 编写「可读」代码的实践淘宝 Fed 叶斋 http://taobaofed.org/blog/2017/01/05/writing-readable-code/ 1.1 变量命名 驼峰 使用名词来命名对象，使用动词来命名函数 对于集合来说：也可以加上 List（数组）或 Map（对象）后缀来显式表示出来 对于函数来说：建议动＋宾＋补 如：fetchUserInfoAsync 12monkey.eat(banana); // the money eats a bananaconst apple = pick(tree); // pick an apple from the tree 1.1.1 命名的上下文变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。 不同上下文更应根据实际情况而定。 1.1.2 严格遵循一种命名规范的收益特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。 也就是说，命名规范后，对于一种场景，只有一个函数命名方式。 （是否需要整理一个常用动词、名词list？） 1.2 分支结构大体认同，但是实践的时候，需要考虑很多特殊情况。 1.2.1 不好的做法：在分支中 return1.2.2 不好的做法：多个条件复合1.2.3 不好的做法：使用分支改变环境1.3 函数1.3.1 函数只做一件事情比如：1234567891011async function fetchUserInfo(id) &#123; const isSingle = typeof idList === &apos;string&apos;; const idList = isSingle ? [id] : id; const result = await request.post(&apos;/api/userInfo&apos;, &#123;idList&#125;); return isSingle ? result[0] : result;&#125;// 可以这样调用const userList = await fetchUserInfo([&apos;1011&apos;, &apos;1013&apos;]);// 也可以这样调用const user = await fetchUserInfo(&apos;1017&apos;); 可以修改为：1234567async function fetchMultipleUser(idList) &#123; return await request.post(&apos;/api/users/&apos;, &#123;idList&#125;);&#125;async function fetchSingleUser(id) &#123; return await fetchMultipleUser([id])[0];&#125; 那么，如何界定某个函数做的是不是一件事情？我的经验是这样：如果一个函数的参数仅仅包含输入数据（交给函数处理的数据），而没有混杂或暗含有指令（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是一件事情。比如说，改良前的 fetchUserInfo 函数的参数是「多个用户的ID数组或单个用户的ID」，这个「或」字其实就暗含了某种指令。 1.3.2 函数应适当地处理异常注： 有时候需要防御氏编程，保证系统正确，但是有时候同时也应该暴露其他接口的隐患 尝试用try throw代替短路分支的方式 1.3.3 控制函数的副作用使用纯函数 1.3.4 非侵入性地改造函数1.4 类的结构1.4.1 避免滥用成员函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F06%2Fpromise%2Fpromise%2F</url>
      <content type="text"><![CDATA[参考：http://liubin.org/promises-book 1. Promise.resolve &amp; Promise.reject静态方法Promise.resolve(value) &amp; Promise.reject(error)可以认为是new Promise()方法的快捷方式。 12345Promise.resolve(value)new Promise(function(resolve)&#123; resolve(value);&#125;); 12345Promise.reject(new Error("出错了"))new Promise(function(resolve,reject)&#123; reject(new Error("出错了"));&#125;); 2. Thenablethenable指的是一个具有.then方法的对象，利用thenable对象原来具有的then方法，将thenable对象转换为promise对象。 12345var promise = Promise.resolve($.ajax('/json/comment.json')); // =&gt; promise对象promise.then(function(value)&#123; console.log(value);&#125;); 3. Promise#catchPromise#catch只是promise.then(undefined, onRejected); 方法的一个别名而已 3.1 每次调用then都会返回一个新创建的promise对象Promise Anti-patterns 3.2 使用promise.then(onFulfilled, onRejected)，在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。3.3 resolve &amp; reject 同一个then里，resolve和reject函数不会同时进行。只执行最先出现的。 一个错误被catch或then中的reject，则不会继续传递下去 1234567891011121314151617var getInfo = function (info) &#123; return new Promise(function (resolve, reject) &#123; reject(111) setTimeout(function () &#123; console.log(resolve) resolve(info) &#125;, 3000) &#125;)&#125;getInfo('test').then(function (info) &#123; console.log(info)&#125;, null).catch(function (err) &#123; console.log(2) console.log(err)&#125;) 4. Promise.all &amp; Promise.race当参数数组中所有的promise对象都变为resolve的时候，该方法才会返回，新创建的promise则会使用这些promise的值。如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象。 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3]&#125;); 数组中的任何一个promise对象如果变为resolve或者reject的话，该函数就会返回，并使用这个promise对象的值进行resolve或者reject。 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.race([p1, p2, p3]).then(function (value) &#123; console.log(value); // 1&#125;);]]></content>
    </entry>

    
  
  
</search>
