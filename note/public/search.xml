<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Iterm2 Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fiterm2%2F</url>
      <content type="text"><![CDATA[基本操作12345678910111213control + a: 到行首control + e: 行末control + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快control + p: 上一条命令，相当于方向键上control + r: 搜索命令历史，这个大家都应该很熟悉了control + d: 删除当前字符control + h: 删除之前的字符control + w: 删除光标前的单词control + k: 删除到文本末尾control + t: 交换光标处文本control + u: 删除一行 + —/+/0: 调整字体大小⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到 参考http://hujiandong.com/2016/09/11/iterm2/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fsublime%2F</url>
      <content type="text"><![CDATA[1. 设置lnln /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl sublime 2. short-cuts2.1 Key Bindings - Default/User2.2 常用123456789option -&gt;/&lt;-option shift -&gt;/&lt;-command -&gt;/&lt;-command ［上］/［下］command entercommand Lcommand K+Bctrl shift M 选中代码块ctrl command G 选中相同的代码 3. 命令行sublime.log_commands(True) 4. package git 12345[ &#123; &quot;keys&quot;: [&quot;super+alt+g+a&quot;], &quot;command&quot;: &quot;git_raw&quot;, &quot;args&quot;: &#123;&quot;command&quot;: &quot;git add -A&quot; &#125;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+g+c&quot;], &quot;command&quot;: &quot;git_commit&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+g+p&quot;], &quot;command&quot;: &quot;git_raw&quot;, &quot;args&quot;: &#123;&quot;command&quot;: &quot;git push&quot; &#125;&#125;,] SyncedSideBar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tmux Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Ftmux%2F</url>
      <content type="text"><![CDATA[1. tmux a2. ctrl+B [ctrl+Bfix]3. 浏览历史ctrl+B [ 4. 新建ctrl+B C 5. 切换ctrl+B 1 6. 分屏ctrl+B %ctrl+B “ 7. 分屏到单屏ctrl+B z 8. 控制分屏大小ctrl+B alt＋&lt;- 9. 多个tmuxtmux new -s yuhangctrl+B s 10. tmux 配置 新建文件 ~/.tmux.conf 配置 1234567891011# 支持鼠标set -g mouse on# 已经废弃set -g mode-mouse onset -g mouse-resize-pane onset -g mouse-select-pane onset -g mouse-select-window on# 更改prefix键set -g prefix C-a 保存prefixsource-fille ~/.tmux.conf]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Yarn 基本介绍]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fyarn%2F</url>
      <content type="text"><![CDATA[1. 什么是yarn？2. yarn有什么好处？3. 性能如何？yarn的官网给出如下数据（yarn VS npm）：从warm cache, node_modules, Lockfile/Shrinkwarp 3个参数，8个维度进行比较。比较结果如下： 大部分情况下，yarn远胜于npm。 3. 安装3.1 下载安装mac操作系统： 用homebrew安装 12brew updatebrew install yarn 用curl安装 1curl -o- -L https://yarnpkg.com/install.sh | bash 用tarball安装 123cd /optwget https://yarnpkg.com/latest.tar.gztar zvxf yarn-*.tar.gz 3.2 环境变量修改：1export PATH=&quot;$HOME/.yarn/bin:$PATH 4. 使用 参考官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 代码管理]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F08%2Fjavascript%2FJS%20%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[1. 编写「可读」代码的实践淘宝 Fed 叶斋 http://taobaofed.org/blog/2017/01/05/writing-readable-code/ 1.1 变量命名 驼峰 使用名词来命名对象，使用动词来命名函数 对于集合来说：也可以加上 List（数组）或 Map（对象）后缀来显式表示出来 对于函数来说：建议动＋宾＋补 如：fetchUserInfoAsync 12monkey.eat(banana); // the money eats a bananaconst apple = pick(tree); // pick an apple from the tree 1.1.1 命名的上下文变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。 不同上下文更应根据实际情况而定。 1.1.2 严格遵循一种命名规范的收益特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。 也就是说，命名规范后，对于一种场景，只有一个函数命名方式。 （是否需要整理一个常用动词、名词list？） 1.2 分支结构大体认同，但是实践的时候，需要考虑很多特殊情况。 1.2.1 不好的做法：在分支中 return1.2.2 不好的做法：多个条件复合1.2.3 不好的做法：使用分支改变环境1.3 函数1.3.1 函数只做一件事情比如：1234567891011async function fetchUserInfo(id) &#123; const isSingle = typeof idList === &apos;string&apos;; const idList = isSingle ? [id] : id; const result = await request.post(&apos;/api/userInfo&apos;, &#123;idList&#125;); return isSingle ? result[0] : result;&#125;// 可以这样调用const userList = await fetchUserInfo([&apos;1011&apos;, &apos;1013&apos;]);// 也可以这样调用const user = await fetchUserInfo(&apos;1017&apos;); 可以修改为：1234567async function fetchMultipleUser(idList) &#123; return await request.post(&apos;/api/users/&apos;, &#123;idList&#125;);&#125;async function fetchSingleUser(id) &#123; return await fetchMultipleUser([id])[0];&#125; 那么，如何界定某个函数做的是不是一件事情？我的经验是这样：如果一个函数的参数仅仅包含输入数据（交给函数处理的数据），而没有混杂或暗含有指令（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是一件事情。比如说，改良前的 fetchUserInfo 函数的参数是「多个用户的ID数组或单个用户的ID」，这个「或」字其实就暗含了某种指令。 1.3.2 函数应适当地处理异常注： 有时候需要防御氏编程，保证系统正确，但是有时候同时也应该暴露其他接口的隐患 尝试用try throw代替短路分支的方式 1.3.3 控制函数的副作用使用纯函数 1.3.4 非侵入性地改造函数1.4 类的结构1.4.1 避免滥用成员函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F06%2Fpromise%2Fpromise%2F</url>
      <content type="text"><![CDATA[参考：http://liubin.org/promises-book 1. Promise.resolve &amp; Promise.reject静态方法Promise.resolve(value) &amp; Promise.reject(error)可以认为是new Promise()方法的快捷方式。 12345Promise.resolve(value)new Promise(function(resolve)&#123; resolve(value);&#125;); 12345Promise.reject(new Error("出错了"))new Promise(function(resolve,reject)&#123; reject(new Error("出错了"));&#125;); 2. Thenablethenable指的是一个具有.then方法的对象，利用thenable对象原来具有的then方法，将thenable对象转换为promise对象。 12345var promise = Promise.resolve($.ajax('/json/comment.json')); // =&gt; promise对象promise.then(function(value)&#123; console.log(value);&#125;); 3. Promise#catchPromise#catch只是promise.then(undefined, onRejected); 方法的一个别名而已 3.1 每次调用then都会返回一个新创建的promise对象Promise Anti-patterns 3.2 使用promise.then(onFulfilled, onRejected)，在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。3.3 resolve &amp; reject 同一个then里，resolve和reject函数不会同时进行。只执行最先出现的。 一个错误被catch或then中的reject，则不会继续传递下去 1234567891011121314151617var getInfo = function (info) &#123; return new Promise(function (resolve, reject) &#123; reject(111) setTimeout(function () &#123; console.log(resolve) resolve(info) &#125;, 3000) &#125;)&#125;getInfo('test').then(function (info) &#123; console.log(info)&#125;, null).catch(function (err) &#123; console.log(2) console.log(err)&#125;) 4. Promise.all &amp; Promise.race当参数数组中所有的promise对象都变为resolve的时候，该方法才会返回，新创建的promise则会使用这些promise的值。如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象。 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3]&#125;); 数组中的任何一个promise对象如果变为resolve或者reject的话，该函数就会返回，并使用这个promise对象的值进行resolve或者reject。 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.race([p1, p2, p3]).then(function (value) &#123; console.log(value); // 1&#125;);]]></content>
    </entry>

    
  
  
</search>
