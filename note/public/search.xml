<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS 代码管理]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F08%2Fjavascript%2FJS%20%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[1. 编写「可读」代码的实践淘宝 Fed 叶斋 http://taobaofed.org/blog/2017/01/05/writing-readable-code/ 1.1 变量命名 驼峰 使用名词来命名对象，使用动词来命名函数 对于集合来说：也可以加上 List（数组）或 Map（对象）后缀来显式表示出来 对于函数来说：建议动＋宾＋补 如：fetchUserInfoAsync 12monkey.eat(banana); // the money eats a bananaconst apple = pick(tree); // pick an apple from the tree 1.1.1 命名的上下文变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。 不同上下文更应根据实际情况而定。 1.1.2 严格遵循一种命名规范的收益特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。 也就是说，命名规范后，对于一种场景，只有一个函数命名方式。 （是否需要整理一个常用动词、名词list？） 1.2 分支结构大体认同，但是实践的时候，需要考虑很多特殊情况。 1.2.1 不好的做法：在分支中 return1.2.2 不好的做法：多个条件复合1.2.3 不好的做法：使用分支改变环境1.3 函数1.3.1 函数只做一件事情比如：1234567891011async function fetchUserInfo(id) &#123; const isSingle = typeof idList === &apos;string&apos;; const idList = isSingle ? [id] : id; const result = await request.post(&apos;/api/userInfo&apos;, &#123;idList&#125;); return isSingle ? result[0] : result;&#125;// 可以这样调用const userList = await fetchUserInfo([&apos;1011&apos;, &apos;1013&apos;]);// 也可以这样调用const user = await fetchUserInfo(&apos;1017&apos;); 可以修改为：1234567async function fetchMultipleUser(idList) &#123; return await request.post(&apos;/api/users/&apos;, &#123;idList&#125;);&#125;async function fetchSingleUser(id) &#123; return await fetchMultipleUser([id])[0];&#125; 那么，如何界定某个函数做的是不是一件事情？我的经验是这样：如果一个函数的参数仅仅包含输入数据（交给函数处理的数据），而没有混杂或暗含有指令（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是一件事情。比如说，改良前的 fetchUserInfo 函数的参数是「多个用户的ID数组或单个用户的ID」，这个「或」字其实就暗含了某种指令。 1.3.2 函数应适当地处理异常注： 有时候需要防御氏编程，保证系统正确，但是有时候同时也应该暴露其他接口的隐患 尝试用try throw代替短路分支的方式 1.3.3 控制函数的副作用使用纯函数 1.3.4 非侵入性地改造函数1.4 类的结构1.4.1 避免滥用成员函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F06%2Fpromise%2Fpromise%2F</url>
      <content type="text"><![CDATA[参考：http://liubin.org/promises-book 1. Promise.resolve &amp; Promise.reject静态方法Promise.resolve(value) &amp; Promise.reject(error)可以认为是new Promise()方法的快捷方式。 12345Promise.resolve(value)new Promise(function(resolve)&#123; resolve(value);&#125;); 12345Promise.reject(new Error("出错了"))new Promise(function(resolve,reject)&#123; reject(new Error("出错了"));&#125;); 2. Thenablethenable指的是一个具有.then方法的对象，利用thenable对象原来具有的then方法，将thenable对象转换为promise对象。 12345var promise = Promise.resolve($.ajax('/json/comment.json')); // =&gt; promise对象promise.then(function(value)&#123; console.log(value);&#125;); 3. Promise#catchPromise#catch只是promise.then(undefined, onRejected); 方法的一个别名而已 3.1 每次调用then都会返回一个新创建的promise对象Promise Anti-patterns 3.2 使用promise.then(onFulfilled, onRejected)，在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。3.3 resolve &amp; reject 同一个then里，resolve和reject函数不会同时进行。只执行最先出现的。 一个错误被catch或then中的reject，则不会继续传递下去 1234567891011121314151617var getInfo = function (info) &#123; return new Promise(function (resolve, reject) &#123; reject(111) setTimeout(function () &#123; console.log(resolve) resolve(info) &#125;, 3000) &#125;)&#125;getInfo('test').then(function (info) &#123; console.log(info)&#125;, null).catch(function (err) &#123; console.log(2) console.log(err)&#125;) 4. Promise.all &amp; Promise.race当参数数组中所有的promise对象都变为resolve的时候，该方法才会返回，新创建的promise则会使用这些promise的值。如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象。 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3]&#125;); 数组中的任何一个promise对象如果变为resolve或者reject的话，该函数就会返回，并使用这个promise对象的值进行resolve或者reject。 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.race([p1, p2, p3]).then(function (value) &#123; console.log(value); // 1&#125;);]]></content>
    </entry>

    
  
  
</search>
