<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[2016年Chrome Dev Summit - 搭建PWA]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F14%2Fchrome%2Fchrome-dev-summit-2016-pwa%2F</url>
      <content type="text"><![CDATA[By Thao Tran Flipkart － bring web back 1. What exactly is a PWA? Radically improving web user experiences (根本上提高用户体验) 2. Buiding PWA is a journey BaselineBaseline PWA checklistLighthouse: Open Source Tool Exemplary(典范) 3. What’s the big deal? examplesAlibaba, Housing.com, west elm, infoba, lyft, make my trip 4. How do I get started? The Weather Company Example move to https web push nxotifications PWAs 5. Approaches to building PWAs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年Chrome Dev Summit - Keynote]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F13%2Fchrome%2Fchrome-dev-summit-2016-keynote%2F</url>
      <content type="text"><![CDATA[By Darin Fisher (VP of Chrome) 1. Web is Reach 2 billion chrome browsers Links (physical web) Polymon every tap lose 20% potential users mobile over desktop 60% 2G 2. Web is World-Wide Internet Users 720 million in China 30% growth in India in 2016 65% (860 million) in India not yet online 3. PWA (Progressive Web App)3.1 Demo CNET demo offline Alibaba 76% higher conversions Single’s display 3.2 Reliable, Fast, Engaging Service Worker API If you wound’t make eye contact with a stranger for the time it takes your web app to first paint, it’s too slow. – Monica Dinosaurescu 5 sec on 3G (http2 / Service Worker) add to Home Screen 4x more often (Alibaba) yields 48% more installs look and feel native across Android Push Notifications 18 billion push notifications sent daily 50,000 domains using push Carnival example 24% opt-in rate 40% open rate seamless sign-in -85% sign failure (AliExpress) +11% conversion (AliExpress) 10% increase in desktop login (Pinterest) Web Payment 4. ProductivityHow developers make web better Lighthouse Real-world Condition Testing (Dev Tools) Security &amp; Application Developer Tools Web Components &amp; Polymer web components v1 Polymer V2 Polymer App Toolbox beta.webcomponents.org AMP (accelerated mobile pages) 5. PredictabilityImproving the web for developers. The Web should ‘Just Work’ for developers.Make whole web works, and collaborate with other browser vendor browser bug search PWA Roadshow web assemble, web GL, web VR/AR, IoT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[position sticky属性回归Chrome]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F12%2Fcss%2Fsticky%2F</url>
      <content type="text"><![CDATA[原文:https://developers.google.com/web/updates/2016/12/position-sticky作者：Paul Kinlan (Paul is a Developer Advocate) Four years ago Eric Bidelman created a rather awesome blog post about the fact that position: sticky landed in WebKit, which at the time was the engine that powered Chrome (as well as many other browsers including Safari). One year later, and much to the consternation of web developers we removed position:sticky from Chrome because “the current implementation isn’t designed in a way that integrates well with the existing scrolling and compositing system”. We’ve always wanted to get it back in to Chrome as the bug stated, “Once we’ve got our scrolling and compositing house in order, we should return to position: sticky and implement the feature in a way that integrates well with the rest of the engine”. The meta bug tracking the implementation has been worked on since 2013. The great news is that as of Chrome 56 (currently beta as of December 2016, stable in Jan 2017) position: sticky is now back in Chrome. What is position:sticky?It’s taken a little while to get here, so why am I excited about it? position:sticky is a CSS positioning attribute that allows you to fix an element to the viewport (i.e, anchor it to the top of the screen) but only when its parent is visible in the viewport and it is within the threshold value. When it is not fixed to the viewport, the element will act like it is position: relative. It is a very nice and simple addition to the platform that removes the need to use JavaScript in an onscroll event handler just to lock an element to the top of the viewport. This is what it looks like on my blog. It allows me to keep the current section’s header at the top of the screen whilst you read my rather long and laborious articles :\ To implement this feature specify that the position attribute should have the value of sticky on the element that you want to be, er, stuck. Additionally, you can also add in the offset at where it needs to be stuck. 123456h3 &#123; /* Element will be 'fixed' when it ... */ position: sticky; /* ... is 10px from the top of the viewport */ top: 10px;&#125; 视频：[https://youtu.be/2EmbqcTMqQw]https://youtu.be/2EmbqcTMqQw The previous example will fix the ‘h3’ element at 10px from the top of the viewport. To fix it directly to the top of the viewport you would set the top attribute as top: 0px. Support for this feature is pretty strong. It is available on Chrome (yay), Firefox and Safari. Here are more details about position:sticky: Specification MDN]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定制化富媒体消息通知与处理播放列表]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F11%2Fchrome%2Fmedia-notification%2F</url>
      <content type="text"><![CDATA[原文: https://developers.google.com/web/updates/2017/02/media-session作者：François Beaufort (Taylor is a PM on the Chrome Team, focusing on Web Components and Polymer.) With the brand new Media Session API, you can now customize media notifications by providing metadata for the media your web app is playing. It also allows you to handle media related events such as seeking or track changing which may come from notifications or media keys. Excited? Try out the official Media Session sample. Chrome 57将对Media Session API提供支持。Chrome 57的beta版本将于2017年2月发布，而稳定版本将于2017年3月发布。 照片由Michael Alø-Nielsen提供 1. 给我所想You already know about the Media Session API and are simply coming back to copy and paste with no shame some boilerplate code? So here it is. 你或许已经听说过Media Session API，但也许只是来回复制和粘贴一些简单的样板代码，就像下面一样。1234567891011121314151617181920212223if ('mediaSession' in navigator) &#123; navigator.mediaSession.metadata = new MediaMetadata(&#123; title: 'Never Gonna Give You Up', artist: 'Rick Astley', album: 'Whenever You Need Somebody', artwork: [ &#123; src: 'https://dummyimage.com/96x96', sizes: '96x96', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/128x128', sizes: '128x128', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/192x192', sizes: '192x192', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/256x256', sizes: '256x256', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/384x384', sizes: '384x384', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/512x512', sizes: '512x512', type: 'image/png' &#125;, ] &#125;); navigator.mediaSession.setActionHandler('play', function() &#123;&#125;); navigator.mediaSession.setActionHandler('pause', function() &#123;&#125;); navigator.mediaSession.setActionHandler('seekbackward', function() &#123;&#125;); navigator.mediaSession.setActionHandler('seekforward', function() &#123;&#125;); navigator.mediaSession.setActionHandler('previoustrack', function() &#123;&#125;); navigator.mediaSession.setActionHandler('nexttrack', function() &#123;&#125;);&#125; 2. 看看代码2.1 开始播放 🎷在你的网页中添加audio标签和多个媒体资源，浏览器会从中选择最佳资源。 1234&lt;audio controls&gt; &lt;source src="audio.mp3" type="audio/mp3"/&gt; &lt;source src="audio.ogg" type="audio/ogg"/&gt;&lt;/audio&gt; 注意: 我也可以用标签来展示Media Session API例子。 As you may know, autoplay is disabled for audio elements on Chrome for Android which means we have to use the play() method of the audio element. This method must be triggered by a user gesture such as a touch or a mouse click. That means listening to pointerup, click, and touchend events. In other words, the user must click a button before your web app can actually make noise. 12345678playButton.addEventListener('pointerup', function(event) &#123; let audio = document.querySelector('audio'); // User interacted with the page. Let's play audio... audio.play() .then(_ =&gt; &#123; /* Set up media session... */ &#125;) .catch(error =&gt; &#123; console.log(error) &#125;);&#125;); Note: If the element has the controls attribute, you can simply set up the media session in the audio play event listener instead which occurs when user taps the “play” audio control. If you don’t want to play audio right after the first interaction, I recommend you use the load() method of the audio element. This is one way for the browser to keep track of whether the user interacted with the element. Note that it may also help smooth the playback because the content will already be loaded. 123456789101112131415let audio = document.querySelector('audio');welcomeButton.addEventListener('pointerup', function(event) &#123; // User interacted with the page. Let's load audio... audio.load() .then(_ =&gt; &#123; /* Show play button for instance... */ &#125;) .catch(error =&gt; &#123; console.log(error) &#125;);&#125;);// Later...playButton.addEventListener('pointerup', function(event) &#123; audio.play() .then(_ =&gt; &#123; /* Set up media session... */ &#125;) .catch(error =&gt; &#123; console.log(error) &#125;);&#125;); 2.2 定制化通知When your web app is playing audio, you can already see a media notification sitting in the notification tray. On Android, Chrome does its best to show appropriate information by using the document’s title and the largest icon image it can find. Without media sessionWith media session 2.2.1 Set metadataLet’s see how to customize this media notification by setting some media session metadata such as the title, artist, album name, and artwork with the Media Session API. 1234567891011121314151617// When audio starts playing...if ('mediaSession' in navigator) &#123; navigator.mediaSession.metadata = new MediaMetadata(&#123; title: 'Never Gonna Give You Up', artist: 'Rick Astley', album: 'Whenever You Need Somebody', artwork: [ &#123; src: 'https://dummyimage.com/96x96', sizes: '96x96', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/128x128', sizes: '128x128', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/192x192', sizes: '192x192', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/256x256', sizes: '256x256', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/384x384', sizes: '384x384', type: 'image/png' &#125;, &#123; src: 'https://dummyimage.com/512x512', sizes: '512x512', type: 'image/png' &#125;, ] &#125;);&#125; Once playback is done, you don’t have to “release” the media session as the notification will automatically disappear. Keep in mind that current navigator.mediaSession.metadata will be used when any playback starts. This is why you need to update it to make sure you’re always showing relevant information in the media notification. 2.2.2 Previous track / next trackIf your web app provides a playlist, you may want to allow the user to navigate through your playlist directly from the media notification with some “Previous Track” and “Next Track” icons. 123456789101112131415161718192021222324252627let audio = document.createElement('audio');let playlist = ['audio1.mp3', 'audio2.mp3', 'audio3.mp3'];let index = 0;navigator.mediaSession.setActionHandler('previoustrack', function() &#123; // User clicked "Previous Track" media notification icon. index = (index - 1 + playlist.length) % playlist.length; playAudio();&#125;);navigator.mediaSession.setActionHandler('nexttrack', function() &#123; // User clicked "Next Track" media notification icon. index = (index + 1) % playlist.length; playAudio();&#125;);function playAudio() &#123; audio.src = playlist[index]; audio.play() .then(_ =&gt; &#123; /* Set up media session... */ &#125;) .catch(error =&gt; &#123; console.log(error); &#125;);&#125;playButton.addEventListener('pointerup', function(event) &#123; playAudio();&#125;); Note that media action handlers will persist. This is very similar to the event listener pattern except that handling an event means that the browser stops doing any default behaviour and uses this as a signal that your web app supports the media action. Hence, media action controls won’t be shown unless you set the proper action handler. By the way, unsetting a media action handler is as easy as assigning it to null. 2.2.3 Seek backward / seek forwardThe Media Session API allows you to show “Seek Backward” and “Seek Forward” media notification icons if you want to control the amount of time skipped. 1234567891011let skipTime = 10; // Time to skip in secondsnavigator.mediaSession.setActionHandler('seekbackward', function() &#123; // User clicked "Seek Backward" media notification icon. audio.currentTime = Math.max(audio.currentTime - skipTime, 0);&#125;);navigator.mediaSession.setActionHandler('seekforward', function() &#123; // User clicked "Seek Forward" media notification icon. audio.currentTime = Math.min(audio.currentTime + skipTime, audio.duration);&#125;); 2.2.4 Play / pauseThe “Play/Pause” icon is always shown in the media notification and the related events are handled automatically by the browser. If for some reason the default behaviour doesn’t work out, you can still handle “Play” and “Pause” media events. 12345678910navigator.mediaSession.setActionHandler('play', function() &#123; // User clicked "Play" media notification icon. // Do something more than just playing current audio...&#125;);navigator.mediaSession.setActionHandler('pause', function() &#123; // User clicked "Pause" media notification icon. // Do something more than just pausing current audio...&#125;);Note: The browser may consider that the web app is not playing media when files are seeking or loading. You can override this behaviour by setting navigator.mediaSession.playbackState to "playing" or "paused". This comes in handy when you want to make sure your web app UI stays in sync with the media notification controls. 3. Notifications everywhereThe cool thing about the Media Session API is that the notification tray is not the only place where media metadata and controls are visible. The media notification is synced automagically to any paired wearable device. And it also shows up on lock screens. Lock Screen - Photo by Michael Alø-Nielsen / CC BY 2.0Wear Notification 4. Make it play nice offlineI know what you’re thinking now… service worker to the rescue! True but first and foremost, you want to make sure all items in this checklist are checked: All media and artwork files are served with the appropriate Cache-Control HTTP header. This will allow the browser to cache and reuse previously fetched resources. See the Caching checklist. Make sure all media and artwork files are served with the Allow-Control-Allow-Origin: * HTTP header. This will allow third-party web apps to fetch and consume HTTP responses from your web server. 4.1 The service worker caching strategyRegarding media files, I recommend a simple “Cache, falling back to network” strategy as illustrated by Jake Archibald. For artwork though, I’d be a little bit more specific and choose the approach below: If artwork is already in the cache, serve it from the cache Else fetch artwork from the network If fetch is successful, add network artwork to the cache and serve it Else serve the fallback artwork from the cache That way, media notifications will always have a nice artwork icon even when browser can’t fetch them. Here’s how you could implement this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const FALLBACK_ARTWORK_URL = 'fallbackArtwork.png';self.addEventListener('install', event =&gt; &#123; self.skipWaiting(); event.waitUntil(initArtworkCache());&#125;);function initArtworkCache() &#123; caches.open('artwork-cache-v1') .then(cache =&gt; cache.add(FALLBACK_ARTWORK_URL));&#125;self.addEventListener('fetch', event =&gt; &#123; if (/artwork-[0-9]+\.png$/.test(event.request.url)) &#123; event.respondWith(handleFetchArtwork(event.request)); &#125;&#125;);function handleFetchArtwork(request) &#123; // Return cache request if it's in the cache already, otherwise fetch // network artwork. return getCacheArtwork(request) .then(cacheResponse =&gt; cacheResponse || getNetworkArtwork(request));&#125;function getCacheArtwork(request) &#123; return caches.open('artwork-cache-v1') .then(cache =&gt; cache.match(request));&#125;function getNetworkArtwork(request) &#123; // Fetch network artwork. return fetch(request) .then(networkResponse =&gt; &#123; if (networkResponse.status !== 200) &#123; return Promise.reject('Network artwork response is not valid'); &#125; // Add artwork to the cache for later use and return network response. addArtworkToCache(request, networkResponse.clone()) return networkResponse; &#125;) .catch(error =&gt; &#123; // Return cached fallback artwork. return getCacheArtwork(new Request(FALLBACK_ARTWORK_URL)) &#125;);&#125;function addArtworkToCache(request, response) &#123; return caches.open('artwork-cache-v1') .then(cache =&gt; cache.put(request, response));&#125; Caution: If you want your service worker to be able to intercept artwork network requests on the very first page load, you may want to call clients.claim() within your service worker once it’s activated. 4.2 Let user control cacheAs the user consumes content from your web app, media and artwork files may take a lot of space on their device. It is your responsibility to show how much cache is used and give users the ability to clear it. Thankfully for us, doing so is pretty easy with the Cache API. 12345678910111213141516171819202122232425262728293031// Here's how I'd compute how much cache is used by artwork files...caches.open('artwork-cache-v1').then(cache =&gt; cache.matchAll()).then(responses =&gt; &#123; let cacheSize = 0; let blobQueue = Promise.resolve(); responses.forEach(response =&gt; &#123; let responseSize = response.headers.get('content-length'); if (responseSize) &#123; // Use content-length HTTP header when possible. cacheSize += Number(responseSize); &#125; else &#123; // Otherwise, use the uncompressed blob size. blobQueue = blobQueue.then(_ =&gt; response.blob()) .then(blob =&gt; &#123; cacheSize += blob.size; blob.close(); &#125;); &#125; &#125;); return blobQueue.then(_ =&gt; &#123; console.log('Artwork cache is about ' + cacheSize + ' Bytes.'); &#125;);&#125;).catch(error =&gt; &#123; console.log(error); &#125;);// And here's how to delete some artwork files...const artworkFilesToDelete = ['artwork1.png', 'artwork2.png', 'artwork3.png'];caches.open('artwork-cache-v1').then(cache =&gt; Promise.all(artworkFilesToDelete.map(artwork =&gt; cache.delete(artwork)))).catch(error =&gt; &#123; console.log(error); &#125;); 5. Implementation notes Chrome for Android requests “full” audio focus to show media notifications only when the media file duration is at least 5 seconds. Notification artwork support blob URLs and data URLs. If no artwork is defined and there is an icon image at a desirable size, media notifications will use it. Notification artwork size in Chrome for Android is 512x512. For low-end devices, it is 256x256. Dismiss media notifications with audio.src = ‘’. As the Web Audio API doesn’t request Android Audio Focus for historical reasons, the only way to make it work with the Media Session API is to hook up an element as the input source to the Web Audio API. Hopefully, the proposed Web AudioFocus API will improve the situation in the near future. 6. SupportAt the time of writing, Chrome for Android is the only platform that supports the Media Session API. More up-to-date information on browser implementation status can be found on Chrome Platform Status. 7. Samples &amp; demosCheck out our official Chrome Media Session sample featuring Jan Morgenstern’s work.视频地址：https://storage.googleapis.com/media-session/screenrecord.mp4 8. ResourcesMedia Session Spec: https://wicg.github.io/mediasessionSpec Issues: https://github.com/WICG/mediasession/issuesChrome Bugs: https://crbug.com/?q=component:Internals&gt;Media&gt;Session]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web Components v1 - 下一代Web Component规范]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F10%2Fchrome%2Fweb-component-v1%2F</url>
      <content type="text"><![CDATA[原文: https://developers.google.com/web/updates/2017/01/webcomponents-org作者：Taylor Savage (Taylor is a PM on the Chrome Team, focusing on Web Components and Polymer.) Web Components你是否曾经想要构建一个可以跨多个项目使用的，跟框架无关的、可供其他开发者使用的js组件？Web Components可能适合你。 Web Components是一组web平台的新功能。它可以使你创建自己的HTML元素。每一个HTML元素都有一个自定义标签，如，并且拥有所有和原生的内置标签一样的优点。自定义元素也同样拥有属性(properties)、方法(methods)、触发和响应事件(events)，甚至也可以拥有封装好的样式(styles)和DOM树。 通过提供一个基于平台的、底层的组件模型，Web Components可以使你搭建和分享一个可复用的任意元素，从定制化的按钮(button)到复杂的视图，如时间选择器(datepicker)。由于Web Components是通过平台的API实现的，它包含了功能强大的、封装好的原语句(primitives)，你甚至可以把这些自定义元素当作标准的DOM元素，在其他的JS类库和框架中使用。 也许，你之前听说过Web Components的概念，它较早的一个版本(V0规范)曾在Chrome 33实现过。 如今，多亏了浏览器厂商们的合作，下一代Web Components － v1规范，已经得到了广泛支持。Chrome已经在53版本和54版本分别支持了，Web Components规范中的2个主要部分 － Shadow Dom和Custom Elements；Safari在10版本中，支持了Shadow DOM v1规范并且完成了在Webkit内核中对Custom Elements v1规范的实现；Firefox对Shadow DOM和Custom Elements v1规范支持正在开发中；Edge也将对Shadow DOM和Custom Elements支持规划到他们的开发roadmap中。 通过v1规范在浏览器中的实现，你只需要借助ES6的语法，创建一个继承(extends)自HTMLElement的新元素(class)，并将它在浏览器中进行注册，你就可以成功地定义了一个新的自定义元素。例如： 12class MyElement extends HTMLElement &#123;...&#125;window.customElements.define('my-element', MyElement); 新版本的V1规范已经十分强大。我们整理出了Custom Elements V1和Shadow Dom V1的教程，以便你能更好的上手使用。 webcomponents.orgWeb Component社区也同样的在蓬勃发展。我们兴奋地看到了一个基于web component社区的网站 － webcomponents.org的发布。该网站已经集成了一个目录，可供开发者们贡献自己的自定义元素。 webcomponents.org包含了Web Components规范, 来自Web Components社区的更新情况, 开源项目的相关文档和由其他开发者们贡献的自定义元素。 现在，你可以通过类库的方式(如：谷歌的Polymer框架)，或者直接通过底层的Web Component API，开始构建你的第一个自定义元素，然后把它发布到webcomponents.org上。 祝您在组件化之路上，玩的开心！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chrome 56里的新东西]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Fchrome%2Fchrome56%2F</url>
      <content type="text"><![CDATA[原文:https://developers.google.com/web/updates/2017/01/nic56作者：Pete LePage (Pete is a Developer Advocate) 视频：https://youtu.be/F4DfGVbvRpY 支持Web Bluetooth API，Web应用可以和附近的低耗能的蓝牙设备进行通信 ‘position: sticky’来了 - 他可以使所创建的元素正常滚动，直到黏到视口(viewport)的顶部。（译者注：代替之前监听scroll或者touchmove事件） 对所有用户默认使用HTML5 我是Pete LePage(原作者), 让我们深入地看看Chrome 56到底给开发者们带来了什么新东西。 1. Web Bluetooth API到目前为止，和蓝牙设备的通信能力只限于本地应用(native app)。在Chrome 56中，你的Web应用也可以借助Web Bluetooth API和附近蓝牙低耗能设备进行安全、私密的通信。 Web Bluetooth API使用的是GATT协议。该协议可以使你的app和灯泡、玩具、心率监控仪、LED显示器等设备通过几行js代码就可以进行通信。Web Bluetooth能够结合物理网络信标，进而更容易发现附近的设备。 Francois有一篇著名的文章发布在’Updates’上。你可以下载一些简单的demo进行学习，同时你也可以关注Web Bluetooth社区。 2. CSS position: sticky;之前，想要实现头部内容随着页面正常滚动，直到粘在视口顶部这一效果，常常需要监听滚动事件并且在元素上设置relative或fixed属性。由于难以做到操作同步，因此经常会出现视觉上的小跳动。 Chrome现在支持了CSS新特性 - ‘position: sticky;’ - 一个新的元素定位属性。 如果一个元素的position属性是sticky，那么它相当于开始的属性状态是relative，在元素滚动到一个特定位置时变成fixed状态。 使用时，只需要简单地将元素的position属性值设置为sticky，并设置一个何时进行属性变换临界位置值即可。如下： 123456h3 &#123; /* Element will be 'fixed' when it ... */ position: sticky; /* ... is 10px from the top of the viewport */ top: 10px;&#125; Paul Kinlan在’Updates’发布过一篇关于这个属性的文章。 3.默认使用HTML5去年8月，我们宣布我们将默认使用HTML5，进而给用户提供更安全、更高效的体验。这个改变使得Chrome将不使用adobe flash播放器，除非用户在特定的网站需要观看flash内容，最终所有的网站都需要用户授权来在网页上运行flash。 在Chrome 56中，默认使用HTML5已经对所有用户开启，这意味着那些用户之前没有访问过的网站需要引导用户授权来运行flash。 你可以查看更多关于如何引导用户授权运行flash细节和如何检测你的flash网站的建议。 4. 其他当然，还有很多其他的更新。 WebVR的初始测试版本已经可以使用；WebGL 2.0 API已经可以使用；支付请求API新增大量新特性。 如果你想持续关注Chrome的最新进展，你可以在订阅他们的github、关注@ChromiumDev的Twitter，同时你也可以观看Chrome开发者大会的视频，进一步关注Chrome小组的正在研究的炫酷新特性。 我是Pete LePage，马上Chrome 57又要发布了。到时候，我还会在这里告诉你们‘Chrome里的新东西’！ 5. 译者补充：5.1. HTTP 密码和信用卡页面的“Not Secure”警告5.2. 网络蓝牙Web Bluetooth API 5.3. CSS position: sticky5.4. Referrer-Policyhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTMl5标签]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Fhtml5%2Ftag%2F</url>
      <content type="text"><![CDATA[原文:https://www.sitepoint.com/eight-html5-tags-you-might-not-know/?utm_source=frontendfocus&amp;utm_medium=email 1.1 标记和当前用户的相关性，与strong区分，用黄色底标记出来 1.2 应用于footer、aside远离正文；用于不重要的补充说明 1.3 q: 短的行内引用 blockquote: 大段引用 注意和cite进行区分 1.4 结合cite和datetime属性一起使用 s表示删除之后，还有新的更新代替 1.5 label 只能看，不能选 disabled: 里面的options都不可选 1.6 结合input作multi－select12345678910111213&lt;label for=&quot;favourite-sites&quot;&gt; Select your favorite website!&lt;/label&gt;&lt;input type=&quot;url&quot; name=&quot;favourite-sites&quot; id=&quot;favourite-sites&quot; list=&quot;site-list&quot;/&gt;&lt;datalist id=&quot;site-list&quot;&gt; &lt;option value=&quot;http://www.google.com.au&quot;&gt; &lt;option value=&quot;http://www.reddit.com&quot;&gt; &lt;option value=&quot;http://www.sitepoint.com&quot;&gt;&lt;/datalist&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html标准学习]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Fstandard%2Fhtml5%2F</url>
      <content type="text"><![CDATA[4. DOMbasehreftarget 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enum DocumentReadyState &#123; &quot;loading&quot;, &quot;interactive&quot;, &quot;complete&quot; &#125;;[OverrideBuiltins]partial /*sealed*/ interface Document &#123; // resource metadata management [PutForwards=href, Unforgeable] readonly attribute Location? location; attribute DOMString domain; readonly attribute DOMString referrer; attribute DOMString cookie; readonly attribute DOMString lastModified; readonly attribute DocumentReadyState readyState; // DOM tree accessors getter object (DOMString name); attribute DOMString title; attribute DOMString dir; attribute HTMLElement? body; readonly attribute HTMLHeadElement? head; readonly attribute HTMLCollection images; readonly attribute HTMLCollection embeds; readonly attribute HTMLCollection plugins; readonly attribute HTMLCollection links; readonly attribute HTMLCollection forms; readonly attribute HTMLCollection scripts; NodeList getElementsByName(DOMString elementName); // dynamic markup insertion Document open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;); WindowProxy open(DOMString url, DOMString name, DOMString features, optional boolean replace = false); void close(); void write(DOMString... text); void writeln(DOMString... text); // user interaction readonly attribute WindowProxy? defaultView; readonly attribute Element? activeElement; boolean hasFocus(); attribute DOMString designMode; boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;); boolean queryCommandEnabled(DOMString commandId); boolean queryCommandIndeterm(DOMString commandId); boolean queryCommandState(DOMString commandId); boolean queryCommandSupported(DOMString commandId); DOMString queryCommandValue(DOMString commandId); // special event handler IDL attributes that only apply to Document objects [LenientThis] attribute EventHandler onreadystatechange;&#125;;Document implements GlobalEventHandlers; 7. scripts11. Obsolete features11.1 Warnings obsolete permitted DOCTYPE border of ‘img’ when value=”0” [other situation is Non-conforming features] (use CSS instead) language=JavaScript and no type=”text/JavaScript” name on element and value is no empty String maxLength when input type=”number” size when input type=”number” 11.2 Non-conforming features Element Attribute 11.3 Requirements for implementations applet marquee (slides effect use CSS animation instead) frame Application cache Others 12. IANA considerations1IANA:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛视频直播学习笔记]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Flive%2Fqiniu%2F</url>
      <content type="text"><![CDATA[一、《视频直播技术详解》系列之一：开篇参考:《视频直播技术详解》系列之一：开篇 1. 主要流程原作者给的流程图： 1.1 采集 iOS 系统因为软硬件种类不多，硬件适配性较好，所以比较简单。 Android 则不同，市面上硬件机型非常多，难以做到一个库适配所有硬件。 PC 端的采集也跟各种摄像头驱动有关，推荐使用目前市面上最好用的 PC 端开源免费软件 OBS。 1.2 处理 视频处理如模糊效果、水印等也都是在这个环节做。 iOS 端比较知名的是 GPUImage 这个库，提供了丰富端预处理效果，还可以基于这个库自己写算法实现更丰富端效果。 Android 也有 GPUImage 这个库的移植，叫做 android-gpuimage。同时，Google 官方开源了一个伟大的库，覆盖了 Android 上面很多多媒体和图形图像相关的处理。(啥库？没说啊。。。) 1.3 编码 处理硬件兼容性问题。（硬件兼容性？不懂。。。） 在高 fps、低 bitrate 和音质画质之间找到平衡。 iOS 端硬件兼容性较好，可以直接采用硬编。 Android 的硬编的支持则难得多，需要支持各种硬件机型，推荐使用软编。 1.4 推流和传输 从主播端到服务端，从收流服务端到边缘节点，以及再从边缘节点到观众端。 推流端和分发端理论上需要支持的并发用户数应该都是亿级的， 不过毕竟产生内容的推流端在少数对推流稳定性和速度的要求比播放端高很多 现在的CDN不靠谱 你能够借助CDN快速实现大规模的流分发 但是稳定高速的推流上传可能还需要自己做很多工作 七牛打造了一个直播专属的实时流网络 1.5 转码 转码成不同格式支持不同协议如 RTMP、HLS 和 FLV，一路转多路流来适配各种不同的网络状况和不同分辨率的终端设备。 内容识别，如：鉴黄功能。 1.6 解码和渲染 iOS 端的播放兼容性较好，在延迟可接受的情况下使用 HLS 协议是最好的选择 + RTMP 和 HLS 的播放器 SDK。 Android 的硬件解码和编码一样也存在兼容性问题，目前比较好的开源播放器是基于 ffplay 的 ijkplayer + Android SDK。 1.7 直播场景化解决方案 社交直播下的聊天、点赞和弹幕的支持 二、《视频直播技术详解》系列之二：采集参考:《视频直播技术详解》系列之二：采集 1. 采集内容1.1 音频采集 模拟信号 －&gt; PCM编码的原始数据（模拟变数字，采样、量化、编码） －&gt; 压缩数据 常见的音频压缩格式有：MP3，AAC，OGG，WMA，Opus，FLAC，APE，m4a 和 AMR 等。 挑战: 延时敏感、卡顿敏感、噪声消除（Denoise）、回声消除（AEC）、静音检测（VAD）和各种混音算法等。(这些是什么？需要好好恶补一下。。。) 技术参数 采样率 位宽：量化（16bit/32bit） 声道数: 录制时的音源数量或回放时相应的扬声器数量 音频帧: 音频数据是流式的，本身没有明确的一帧帧的概念。一般约定为2.5ms~60ms size ＝ 采样率（kHz）X 位宽（bit）X 声道数 X 帧长（ms） 1.2 图像采集 摄像头等设备拍摄成 YUV 编码的原始数据 -&gt; 编码压缩成 H.264 等格式 常见的视频封装格式有：MP4、3GP、AVI、MKV、WMV、MPG、VOB、FLV、SWF、MOV、RMVB 和 WebM 挑战: 设备兼容性差、延时敏感、卡顿敏感以及各种对图像的处理操作如美颜和水印等。 技术参数 图像传输格式: 通用影像传输格式（Common Intermediate Format）是视讯会议（video conference）中常使用的影像传输格式。 图像格式: 通常采用 YUV 格式存储原始数据信息，其中包含用 8 位表示的黑白图像灰度值，以及可由 RGB 三种色彩组合成的彩色图像。 传输通道: 正常情况下只需1路通道，随着VR和AR技术的日渐成熟，为了拍摄一个完整的 360° 视频，可能需要通过不同角度拍摄，然后经过多通道传输后合成。 分辨率: 视频采集卡能支持的最大点阵反映了其分辨率的性能。 采样频率: 采样频率反映了采集卡处理图像的速度和能力。在进行高度图像采集时，需要注意采集卡的采样频率是否满足要求。 实际开发过程中可能很少能够关注采集环节中技术参数的控制，而是直接在 SDK 中将采集后的数据传递给下一个「处理」和「编码」环节。 2. 采集源 2.1 摄像头采集 手机上 ios/Android（&gt;4.0.3） 前后摄像头 专业摄像头：七牛云提供了兼容适合嵌入式系统的C语言采集模块的实现https://github.com/pili-engineering/ipcam_sdk（啥意思？驱动？or 接口？） 2.2 屏幕录制 iOS 9 以上的版本: 通过模拟一个 AirPlay 镜像连接到（当前 App）自身。 Android SDK: 实现了屏幕录制的功能 电脑桌面: 开源的桌面推流工具 OBS 来进行屏幕录制和推流：https://obsproject.com/ 2.3 视频文件 将一个视频或者音频文件以直播流的形式实时传输 2.4 开放式设计（接口） 只要采集源实现方遵循相应的接口，即可支持任意的采集源。 三、《视频直播技术详解》系列之三：处理参考:《视频直播技术详解》系列之三：处理 1. 开放式设计 音频处理中具体包含混音、降噪和声音特效 视频处理中包含美颜、水印、以及各种自定义滤镜 自定义处理 iOS SDK Android SDK 2. 美颜 主要原理: “磨皮”+”美白” 磨皮: 去躁。对图像中的噪点进行去除或者模糊化处理，常见的去噪算法有均值模糊、高斯模糊和中值滤波 + 人脸和皮肤检测技术。 美颜接口(ios SDK)： 按照默认参数开启或关闭美颜: 1(void)setBeautifyModeOn:(BOOL)beautifyModeOn; 设置美颜程度，范围为 0 ~ 1: 1(void)setBeautify:(CGFloat)beautify; 设置美白程度，范围为 0 ~ 1: 1(void)setWhiten:(CGFloat)whiten; 设置红润程度，范围为 0 ~ 1: 1(void)setRedden:(CGFloat)redden; 3. 视频内嵌水印 水印功能接口(ios SDK) 添加水印: 1(void)setWaterMarkWithImage:(UIImage *)wateMarkImage position:(CGPoint)position; 移除水印: 1(void)clearWaterMark; 4. 滤镜 iOS 端可以考虑使用GPUImage这个库。内置了多达120多种常见的滤镜效果。 Android 也有GPUImage这个库的移植 Google 官方也开源了一个伟大的库https://github.com/google/grafika 5. 连麦 技术难点: 低延迟互动 音画同步 视频实时合成: 需要在客户端或者服务端将画面和声音实时合成，然后以低成本高品质的方式传输观众端 思科或者 WebEx 的商用方案: 一不开源，二比较封闭，三成本比较高 WebRTC 通过 RTCPeerConnection API 管理，这个 API 包装了底层流管理和信令控制相关的细节 可以每个点之间形成自组织网络的方式通信;也可以以 1 人为中心形成星型通信网络;还可以让大家都通过一个集中式的服务端进行通信。 七牛直播云经过评估选择了以主播为中心形成星形通信网络，支持主播和多个观众之间的互动质量。 同时，为了保证合成后的音视频实时传输到其他观众端，这里采用经过改造的 UDP 协议传输： 通过 UDP 降低传输延迟。 在 UDP 之上进行传输控制，保证用户互动体验 QoS。 四、《视频直播技术详解》之四：编码和封装参考:《视频直播技术详解》之四：编码和封装 五、《视频直播技术详解》系列之五：推流和传输参考:《视频直播技术详解》系列之五：推流和传输 六、《视频直播技术详解》系列之六：延迟优化参考:《视频直播技术详解》系列之六：延迟优化 七、《视频直播技术详解》系列之七：现代播放器原理参考:《视频直播技术详解》系列之七：现代播放器原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tree-shaking介绍]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Fwebpack%2Ftree-shaking%2F</url>
      <content type="text"><![CDATA[1. 什么是tree-shaking?tree-shaking 由rollup.js提出的feature，使得js（ES2015）在打包的过程中，只需要引入需要用到的js部分，而不需要将整个js模块文件都打包。 2. webpack2如何做tree-shaking两步： - 去除所有没有被import引入的export； - 在minify的过程中，去除没有被用到的其它代码。 参考http://www.2ality.com/2015/12/webpack-tree-shaking.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Iterm2 Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fiterm2%2F</url>
      <content type="text"><![CDATA[基本操作12345678910111213control + a: 到行首control + e: 行末control + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快control + p: 上一条命令，相当于方向键上control + r: 搜索命令历史，这个大家都应该很熟悉了control + d: 删除当前字符control + h: 删除之前的字符control + w: 删除光标前的单词control + k: 删除到文本末尾control + t: 交换光标处文本control + u: 删除一行 + —/+/0: 调整字体大小⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到 参考http://hujiandong.com/2016/09/11/iterm2/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fsublime%2F</url>
      <content type="text"><![CDATA[1. 设置lnln /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl sublime 2. short-cuts2.1 Key Bindings - Default/User2.2 常用123456789option -&gt;/&lt;-option shift -&gt;/&lt;-command -&gt;/&lt;-command ［上］/［下］command entercommand Lcommand K+Bctrl shift M 选中代码块ctrl command G 选中相同的代码 3. 命令行sublime.log_commands(True) 4. package git 12345[ &#123; &quot;keys&quot;: [&quot;super+alt+g+a&quot;], &quot;command&quot;: &quot;git_raw&quot;, &quot;args&quot;: &#123;&quot;command&quot;: &quot;git add -A&quot; &#125;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+g+c&quot;], &quot;command&quot;: &quot;git_commit&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+g+p&quot;], &quot;command&quot;: &quot;git_raw&quot;, &quot;args&quot;: &#123;&quot;command&quot;: &quot;git push&quot; &#125;&#125;,] SyncedSideBar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tmux Cheat Sheet]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Ftmux%2F</url>
      <content type="text"><![CDATA[1. tmux a2. ctrl+B [ctrl+Bfix]3. 浏览历史ctrl+B [ 4. 新建ctrl+B C 5. 切换ctrl+B 1 6. 分屏ctrl+B %ctrl+B “ 7. 分屏到单屏ctrl+B z 8. 控制分屏大小ctrl+B alt＋&lt;- 9. 多个tmuxtmux new -s yuhangctrl+B s 10. tmux 配置 新建文件 ~/.tmux.conf 配置 1234567891011# 支持鼠标set -g mouse on# 已经废弃set -g mode-mouse onset -g mouse-resize-pane onset -g mouse-select-pane onset -g mouse-select-window on# 更改prefix键set -g prefix C-a 保存prefixsource-fille ~/.tmux.conf]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Yarn 基本介绍]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F09%2Ftools%2Fyarn%2F</url>
      <content type="text"><![CDATA[1. 什么是yarn？2. yarn有什么好处？3. 性能如何？yarn的官网给出如下数据（yarn VS npm）：从warm cache, node_modules, Lockfile/Shrinkwarp 3个参数，8个维度进行比较。比较结果如下： 大部分情况下，yarn远胜于npm。 3. 安装3.1 下载安装mac操作系统： 用homebrew安装 12brew updatebrew install yarn 用curl安装 1curl -o- -L https://yarnpkg.com/install.sh | bash 用tarball安装 123cd /optwget https://yarnpkg.com/latest.tar.gztar zvxf yarn-*.tar.gz 3.2 环境变量修改：1export PATH=&quot;$HOME/.yarn/bin:$PATH 4. 使用 参考官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 代码管理]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F08%2Fjavascript%2FJS%20%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[1. 编写「可读」代码的实践淘宝 Fed 叶斋 http://taobaofed.org/blog/2017/01/05/writing-readable-code/ 1.1 变量命名 驼峰 使用名词来命名对象，使用动词来命名函数 对于集合来说：也可以加上 List（数组）或 Map（对象）后缀来显式表示出来 对于函数来说：建议动＋宾＋补 如：fetchUserInfoAsync 12monkey.eat(banana); // the money eats a bananaconst apple = pick(tree); // pick an apple from the tree 1.1.1 命名的上下文变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。 不同上下文更应根据实际情况而定。 1.1.2 严格遵循一种命名规范的收益特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。 也就是说，命名规范后，对于一种场景，只有一个函数命名方式。 （是否需要整理一个常用动词、名词list？） 1.2 分支结构大体认同，但是实践的时候，需要考虑很多特殊情况。 1.2.1 不好的做法：在分支中 return1.2.2 不好的做法：多个条件复合1.2.3 不好的做法：使用分支改变环境1.3 函数1.3.1 函数只做一件事情比如：1234567891011async function fetchUserInfo(id) &#123; const isSingle = typeof idList === &apos;string&apos;; const idList = isSingle ? [id] : id; const result = await request.post(&apos;/api/userInfo&apos;, &#123;idList&#125;); return isSingle ? result[0] : result;&#125;// 可以这样调用const userList = await fetchUserInfo([&apos;1011&apos;, &apos;1013&apos;]);// 也可以这样调用const user = await fetchUserInfo(&apos;1017&apos;); 可以修改为：1234567async function fetchMultipleUser(idList) &#123; return await request.post(&apos;/api/users/&apos;, &#123;idList&#125;);&#125;async function fetchSingleUser(id) &#123; return await fetchMultipleUser([id])[0];&#125; 那么，如何界定某个函数做的是不是一件事情？我的经验是这样：如果一个函数的参数仅仅包含输入数据（交给函数处理的数据），而没有混杂或暗含有指令（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是一件事情。比如说，改良前的 fetchUserInfo 函数的参数是「多个用户的ID数组或单个用户的ID」，这个「或」字其实就暗含了某种指令。 1.3.2 函数应适当地处理异常注： 有时候需要防御氏编程，保证系统正确，但是有时候同时也应该暴露其他接口的隐患 尝试用try throw代替短路分支的方式 1.3.3 控制函数的副作用使用纯函数 1.3.4 非侵入性地改造函数1.4 类的结构1.4.1 避免滥用成员函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise]]></title>
      <url>%2Fnote%2Fpublic%2F2017%2F02%2F06%2Fpromise%2Fpromise%2F</url>
      <content type="text"><![CDATA[参考：http://liubin.org/promises-book 1. Promise.resolve &amp; Promise.reject静态方法Promise.resolve(value) &amp; Promise.reject(error)可以认为是new Promise()方法的快捷方式。 12345Promise.resolve(value)new Promise(function(resolve)&#123; resolve(value);&#125;); 12345Promise.reject(new Error("出错了"))new Promise(function(resolve,reject)&#123; reject(new Error("出错了"));&#125;); 2. Thenablethenable指的是一个具有.then方法的对象，利用thenable对象原来具有的then方法，将thenable对象转换为promise对象。 12345var promise = Promise.resolve($.ajax('/json/comment.json')); // =&gt; promise对象promise.then(function(value)&#123; console.log(value);&#125;); 3. Promise#catchPromise#catch只是promise.then(undefined, onRejected); 方法的一个别名而已 3.1 每次调用then都会返回一个新创建的promise对象Promise Anti-patterns 3.2 使用promise.then(onFulfilled, onRejected)，在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。3.3 resolve &amp; reject 同一个then里，resolve和reject函数不会同时进行。只执行最先出现的。 一个错误被catch或then中的reject，则不会继续传递下去 1234567891011121314151617var getInfo = function (info) &#123; return new Promise(function (resolve, reject) &#123; reject(111) setTimeout(function () &#123; console.log(resolve) resolve(info) &#125;, 3000) &#125;)&#125;getInfo('test').then(function (info) &#123; console.log(info)&#125;, null).catch(function (err) &#123; console.log(2) console.log(err)&#125;) 4. Promise.all &amp; Promise.race当参数数组中所有的promise对象都变为resolve的时候，该方法才会返回，新创建的promise则会使用这些promise的值。如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象。 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3]&#125;); 数组中的任何一个promise对象如果变为resolve或者reject的话，该函数就会返回，并使用这个promise对象的值进行resolve或者reject。 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.race([p1, p2, p3]).then(function (value) &#123; console.log(value); // 1&#125;);]]></content>
    </entry>

    
  
  
</search>
